[
  {
    "id": "ambiguous_constructors",
    "group": "nursery",
    "level": "warn",
    "impl": "typed",
    "docs": "### What it does\n\nChecks if there are constructor names that hide default constructor names\nfrom `Stdlib`, such as `Some`, `None`, `Error`, `Ok`.\n\n### Why it is important\n\nShadowing names of default constructors may lead to name clashes within toplevel.\nUsing custom constructors is recommended.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "camel_cased_types",
    "group": "style",
    "level": "deny",
    "impl": "untyped",
    "docs": "### What it does\nChecks that type names are using snake case (`very_useful_typ`) and not using camel case (`veryUsefulTyp`) popular in Python and Haskell.\n\n### Why is this bad?\nWrong casing is not exactly bad but OCaml tradition says that types' and module types' names should be snake case.\nModules names' in standard library are in camel case but in most Janestreet libraries (ppxlib, base) they are in snake case too.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "camel_extra_dollar",
    "group": "style",
    "level": "deny",
    "impl": "untyped",
    "docs": "### What it does\nThe `@@` operator is used for writing less parentheses in expression.\nCode like `f (g (h x))` could be rewritten as `f @@ g (h x)`.\nBut is some cases it is not required, like `print_int @@ 1`.\nSome of these cases are reported by this lint.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "eta_reduction",
    "group": "style",
    "level": "warn",
    "impl": "typed",
    "docs": "### What it does\nStraightforward wrapper functions are excessive and may be reduced\n\n#### Explanation\n\nLet's look at the expression 'let f x = g x'.\nIt may be simply replaced with an expression, `let f = g` which has the same semantics.\nIn general, wrappers like this may be confusing, so it is recommended to get rid of them.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "exc_error_swallowing",
    "group": "suspicious",
    "level": "deny",
    "impl": "typed",
    "docs": "### What it does\nCatching all possible exceptions with wildcard considered as antipattern\n\nSee also https://en.wikipedia.org/wiki/Error_hiding",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "exc_failwith",
    "group": "suspicious",
    "level": "warn",
    "impl": "typed",
    "docs": "### What it does\nThe usage of 'Stdlib.failwith' in production code could be error-prone. The constructions `failwith \"not implemented\"` should be implemented sooner or later.\n\nConstructions `failwith \"should not happen\"` smells. Maybe techniques from https://doi.org/10.1145/3299711.3242755 could help.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "expect_tests_no_names",
    "group": "style",
    "level": "deny",
    "impl": "untyped",
    "docs": "### What it does\nWarns about expect tests without descriptions: `let%expect_test _ = ...`\n\n### Why?\nFor purposes of refactoring we want to know why a certain test was written.\nIt allows us to decide easily if this test is still needed.\nBetter version is `let%expect_test \"decent name\" = ...`",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "forbid_many_nested_if_expressions",
    "group": "style",
    "level": "deny",
    "impl": "typed",
    "docs": "### What it does\n\nCheck too many (>= 3 levels) nested if expressions, for example\n* `if ... then (if ... then (if ... then (if ... then ... else ...) else ...) else ...) else ...`\n\n### Why it is important\n\nThe big problem with nested conditions is that they confuse the control flow of the code:\nthey make it almost impossible to determine what code will be executed and when.\n\nAdopted from camelot's lint list.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "format_module_usage",
    "group": "correctness",
    "level": "deny",
    "impl": "typed",
    "docs": "### What it does\nOCaml formatted string are more powerful than C counterpart.\nYou should be aware of available features.\n\n### Why is is important?\nShorter code is more readable. Rewrite\n\n*  `\\\"%s\\\"` to `%S`",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "if_bool",
    "group": "style",
    "level": "warn",
    "impl": "typed",
    "docs": "### What it does?\n\nChecks funny uses of boolean expressions, for example\n* `if true ...`\n* `if ... then false`\n* `... && true`\n* etc.\n\n### Why it is important?\n\nThese unwise boolean expressions make code longer than it should be. For example, the expression `f x && false`\nis semantically equivalent to false unless `f x` performs any effect (mutation, IO, exceptions, etc.).\nThe general rule of thumb is not to depend of the order of evaluation of this conjucts.\n(The same idea as our functions should not depend on evaluation order of its' arguments.)",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "lint_filesystem",
    "group": "correctness",
    "level": "deny",
    "impl": "typed",
    "docs": "### What it does\nChecks that dune project tree is well formed\n\n### Why is is important?\n\nAll modules should have .mli interfaces.\nThe .mli files allow to\n\n* hide some structure items\n* write documentation for modules.\n* hide dependencies between modules (i.e. speedup compilation)\n\nWithout .mli files all your functions will be 'public' in the sence of C++ style OOP.\nUsually people autogenerate .mli files and all defined values in that time become public.\nZanuda is able to detect this via `zanuda -unused-decls .`.\nBut in some cases, .mli files may be too heavy, for example, when we write many type\ndeclarations (sort of AST) with deriving attributes.\nIn that case .mli file is almost identical to .ml.\nTo workaround this, this check allows file with a suffix `ast.ml` not to have an .mli interface file.\n\nTODO: Add custom configuration for this.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "list_fusion",
    "group": "perf",
    "level": "warn",
    "impl": "typed",
    "docs": "### What it does\n\nPerforms List fusion (a.k.a. deforestation) for OCaml lists.\n\n#### Explanation\n\nWhen you performing bunch of list operations, for example `List.map f (List.map g ...)` they has a performance problem:\nthe intermediate lists that are created glut a lot of memory. It's recommended to rewrite the code using 'free thorems'.\nSee the original paper [P.Wadler \"Deforestation: transforming programs to eliminate trees\" (1990)](https://homepages.inf.ed.ac.uk/wadler/topics/deforestation.html) for more details.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "list_length_comparisons",
    "group": "perf",
    "level": "deny",
    "impl": "typed",
    "docs": "### What it does\nThe function `Stdlib.List.length` evaluated length of standard OCaml linked lists (`'a list`).\nThe return values supposed to be non-negative, so all code like `List.length .. <= 0` smells bad.\nIf we need to check that list is (not) empty, it is recommended to use pattern matching instead of calculating length (for example, `Base.List.is_empty`).\nIf we do do full iteration, and it will be too inefficient.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "manual_fold",
    "group": "style",
    "level": "deny",
    "impl": "untyped",
    "docs": "### What it does\nProposes to use `List.fold_left` or `List.fold_right` instead of manual\nimplementations, such as:\n\n```ocaml\n  let rec fold_left f acc l = match l with\n  | [] -> acc\n  | x :: xs -> fold_left f (f acc a) l\n```\n\n### Why?\nIt is too verbose and reduces readability.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "manual_map",
    "group": "style",
    "level": "deny",
    "impl": "untyped",
    "docs": "### What it does\nProposes to use `List.map` instead of manual implementation, such as\n\n```ocaml\n  let rec map f = function\n  | [] -> []\n  | x :: xs -> f x :: map f xs\n```\n\n### Why?\nIt is too verbose and most likely less performant.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "match_bool",
    "group": "style",
    "level": "warn",
    "impl": "typed",
    "docs": "### What it does\nProposes to rewrite 'match x with ... | true -> (1)  ... | false -> (2) ` to `if x then (1) else (2)`.\n\n### Why?\nUsing `if` is more readable way to examine boolean value.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "misc_aggregate_defs",
    "group": "style",
    "level": "warn",
    "impl": "typed",
    "docs": "It is not really a lint. It collects locations in the file where types are declared and saves them.\nIf PPX-expanded expressions have issues and locations corresponding type declarations,\nwe don't report these false-positive lints (at the moment, only about possible eta-conversion)",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "monad_laws_simplify",
    "group": "style",
    "level": "deny",
    "impl": "typed",
    "docs": "### What it does?\nWarns if monadic code could be simplified.\n\n### Monad laws\n  1) **return x >>= f === f x** for any  f and x\n  2) **m >>= return === m** for any monadic value m\n  3) **(m >>= g) >>= k  ===  m >>= fun x -> ((g x) >>= k)** for any monadic values m,g,k",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "mutability_check",
    "group": "style",
    "level": "deny",
    "impl": "typed",
    "docs": "### What it does\nUsing mutable data structures for teaching purposes is usually discouraged. Replace \\\nHashtables by standard tree-like maps or consider Hash-Array Mapped Tries (HAMT).\n\n##### How to fix?\nUse mutable `ref`erences and mutable record fields only if it is really required.\nUsually, mutability is added for performance reasons. For example,\n\n  * [Effective generalization](https://okmij.org/ftp/ML/generalization.html) in OCaml type checher\n  * Functions, that count number of invocations and/or generate unique names.\n  * Implementing memoization or laziness",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "mutually_rec_types",
    "group": "style",
    "level": "warn",
    "impl": "typed",
    "docs": "### What it does\nUsing `and` where there is no mutual recursion is discouraged.\n\n#### Explanation\nThe keyword `and` should be used only to declare mutually recursive types or functions.\nIncorrect use of `and` can lead to confusion.\nIt's recommended to rewrite type declarations without `and` where mutual recursion is not required.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "no_docs_parsetree",
    "group": "style",
    "level": "deny",
    "impl": "untyped",
    "docs": "### What it does\nIt checks that file `Parsetree.mli` has documentation comments for all constructors.\nUsually files like this are used to describe abstract syntax tree (AST) of a language.\nIn this case it's recommended to annotate every constructor with a documentation about meaning of the constructors, for example, which real syntax if supposed to be parsed to this part of AST.\n\nAs example of this kind of documentation you can consult [OCaml 4.14.2 parse tree](https://github.com/ocaml/ocaml/blob/4.14.2/parsing/parsetree.mli#L286)",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "no_toplevel_eval",
    "group": "style",
    "level": "deny",
    "impl": "untyped",
    "docs": "### What it does\nAdding toplevel evaluation statements is not recommended because it forces to add `;;`. Rewrite using `let () = ...`",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "physical_equality",
    "group": "correctness",
    "level": "deny",
    "impl": "typed",
    "docs": "### What it does\nWarns about using of physical equality (of pointers) vs. structural equality (of values)\n\n### Why is is important?\nThe newcomers from C++ and C# may automatically write == to test for equality,\nand get unexpected results for complex values.\n\nIf you do low level performance hacking, this lint could give false positives.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "propose_function",
    "group": "style",
    "level": "warn",
    "impl": "typed",
    "docs": "### What it does\nProposes to rewrite 'fun x -> match x with ...' to `function`.\n\n### Why?\nThe `function` keyword allows more shorter syntax for pattern matching on last argument.\nThe lint should not be raised if scrutinee variable is used later in the code.\n\nThe following code is recommended:\n\n```ocaml\n  let f = function\n    | [] -> ...\n    | (x::xs) as arg -> ... x ... xs ... arg\n```\n\nAnd this piece of code is discouraged:\n\n```ocaml\n  let f arg  = match arg with\n    | [] -> ...\n    | (x::xs) -> ... x ... xs ... arg\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "record_punning",
    "group": "style",
    "level": "warn",
    "impl": "typed",
    "docs": "### What it does\nSimplyfies record construction using OCaml-specific field punning.\n\n[Chapter](https://dev.realworldocaml.org/records.html) in 'Real World OCaml'.\n\n##### Examples\n\n```ocaml\n{ x = r.x; y = r.y; z = 15}\n```\nvs\n```ocaml\n{ r with z = 15 }\n```",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "string_concat",
    "group": "perf",
    "level": "allow",
    "impl": "typed",
    "docs": "### What it does\nConcatenating multiple strings at once (`a^b^c`) has a perfomance issue. OCaml needs to allocate\nmemory for the result of\n`a^b` and after that it needs to allocate memory for a result of concatenation `a^b` and `c`,\ni.e. it allocates unneeded memory for intermediate results.\n(The same issue arises in left-associative concatenation of lists).\n\n\n### How to fix\nWe can rewrite using `asprintf`/`sprintf`: `Format.asprintf \"%s%s%s\" a b c`. Internally, it will\nUse [function](https://github.com/ocaml/ocaml/blob/4.14/stdlib/string.ml#L72) `val concat: string -> string list -> string` from standard library.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "string_concat_fold",
    "group": "perf",
    "level": "warn",
    "impl": "typed",
    "docs": "### What it does\nConcatenating multiple strings at once (`a^b^c`) has a perfomance issue. OCaml needs to allocate\nmemory for the result of\n`a^b` and after that it needs to allocate memory for a result of concatenation `a^b` and `c`,\ni.e. it allocates unneeded memory for intermediate results.\nFor concatenations of unbound length situation could be even worse\n\n### How to fix\nWe can rewrite using `List.fold_left (^)` and similar folds of containers using\n[function](https://github.com/ocaml/ocaml/blob/4.14/stdlib/string.ml#L72) `List.concat: string -> string list -> string`,\nwhich calculates the size of final string ahead of time and avoid unneeded allocations.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "top_file_license",
    "group": "correctness",
    "level": "deny",
    "impl": "untyped",
    "docs": "### What it does\nEnsures that every files start from license and copyright information.\nThe description is expected in [SPDX](https://spdx.org/licenses) format.\n\n### Why is this bad?\nThese annotation allow automation tools to check code for license compliance.\n\n````\n[@@@ocaml.text \"/*\"]\n\n(** Copyright 2021-2025, Vasya Pupkin *)\n\n(** SPDX-License-Identifier: LGPL-3.0-only *)\n\n[@@@ocaml.text \"/*\"]\n````\n\nThe `\"/*\"` decorations prevent ocamldoc/odoc from including comments with license into documentation.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "tuple_matching",
    "group": "style",
    "level": "warn",
    "impl": "typed",
    "docs": "### What it does\nUsing match with single tuple is discouraged. It's better to rewrite it with `let (a, b) = scru in rhs`.\n\n#### Explanation\nIt's recommended to rewrite the code as 'let ... in` because is more clearly.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "use_guard_instead_of_if",
    "group": "style",
    "level": "deny",
    "impl": "untyped",
    "docs": "### What it does\nPattern matching guards are not very common in mainstream languages so it easy to forget about them for OCaml wannabies.\nThis lint looks for if-then-else expressions in right hand sides of pattern matching, and recommends to use pattern guards.\n\n### Why is this bad?\nSometimes guards allow you to write less error-prone code. For example, you are matching three values and want to\n. if 1st fits predicate then do something and return, check other components otherwise.\n. if 2nd fits predicate then do something and return, check other components otherwise.\n. if 3rd ..., do something else otherwise.\n\nThe implementation with if-then-else could be like this.\n```ocaml\nmatch ... with\n| (a,b,c) ->\n    if pred1 a then ...\n    else if pred2 b then ...\n    else if pred3 c then ...\n    else ... something_else ...\n| ...\n```\nIn this case all three bindings are in scope in the right hand side of matching, you can by mistake use them for something. And you can't use wildcards because all three bindings are required in right hand side.\n\nLet's rewrite it with guards:\n```ocaml\nmatch ... with\n| (a,_,_) when pred1 a -> ...\n| (_,b,_) when pred2 b -> ...\n| (_,_,c) when pred3 c -> ...\n| ...\n```\n\nIn this variant you have less potential for copy-paste mistake",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "use_match_instead_of_equality",
    "group": "correctness",
    "level": "deny",
    "impl": "typed",
    "docs": "### What it does\nFor most algebraic datatypes it's better to use pattern matching then equality `(=)`. This lint reports that for\nstandard lists, options and bools.\n\nAdopted from camelot's lint list.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "var_should_not_be_used",
    "group": "style",
    "level": "deny",
    "impl": "untyped",
    "docs": "### What it does\nReport identifier starting with '_' and used later\n\n### Why is this bad?\nOCaml compiler has a tendency to report warning 26 about unused variables.\nUsually this warning could be supressed by adding '_' in the beginning of identifier to make it look like wildcard variable.\nBut if that identifier is used later it contradicts the purpose of adding undescore in the beginnning.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "wrong_ignoring",
    "group": "suspicious",
    "level": "warn",
    "impl": "typed",
    "docs": "### What it does\nUsing 'Stdlib.ignore' is discouraged. It's better to rewrite it with let.\n\n#### Explanation\n\nLet's look at expression 'ignore (f x)'. If in the future the function 'f' will accept one more argument or change return type the code above may become buggy, because the function will not be fully applied and executead (although the warning may be raised here if this warning is not masked). It's recommended to rewrite the code as 'let (_ : int) = f x in ...` where 'int' is an example of return type of the function 'f'.",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  }
]