[
  {
    "id": "use_guard_instead_of_if",
    "group": "correctness",
    "level": "deny",
    "impl": "untyped",
    "docs":
      "\n### What it does\nPattern matching guards are not very common in mainstream languages so it easy to forget about them for OCaml wannabies.\nThis lint looks for if-then-else expressions in right hand sides of pattern matching, and recommends to use pattern guards.\n\n### Why is this bad?\nSometimes guards allow you to write less error-prone code. For example, you are matching three values and want to\n. if 1st fits predicate then do something and return, check other components otherwise.\n. if 2nd fits predicate then do something and return, check other components otherwise.\n. if 3rd ..., do something else otherwise.\n\nThe implementation with if-then-else could be like this.\n```ocaml\nmatch ... with\n| (a,b,c) ->\n    if pred1 a then ...\n    else if pred2 b then ...\n    else if pred3 c then ...\n    else ... something_else ...\n| ...\n```\nIn this case all three bindings are in scope in the right hand side of matching, you can by mistake use them for something. And you can't use wildcards because all three bindings are required in right hand side.\n\nLet's rewrite it with guards:\n```ocaml\nmatch ... with\n| (a,_,_) when pred1 a -> ...\n| (_,b,_) when pred2 b -> ...\n| (_,_,c) when pred3 c -> ...\n| ...\n```\n\nIn this variant you have less potential for copy-paste mistake\n  ",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "camel_cased_types",
    "group": "correctness",
    "level": "deny",
    "impl": "untyped",
    "docs":
      "\n### What it does\nChecks that type names are using snake case (`very_useful_typ`) and not using camel case (`veryUsefulTyp`) popular in Python and Haskell.\n\n### Why is this bad?\nWrong casing is not exactly bad but OCaml tradition says that types' and module types' names should be snake case. Modules names' in standard library are in camel case but in most Janestreet libraries (ppxlib, base) they are in snake case too.\n  ",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "no_docs_parsetree",
    "group": "correctness",
    "level": "deny",
    "impl": "untyped",
    "docs":
      "\n### What it does\nIt checks that file `Parsetree.mli` has documentation comments for all constructors. Usually files like this are used to describe abstract syntax tree (AST) of a language. In this case it's recommended to annotate every constructor with a documentation about meaning of the constructors, for example, which real syntax if supposed to be parsed to this part of AST.\n\nAs example of this kind of documentation you can consult [OCaml 4.13 parse tree](https://github.com/ocaml/ocaml/blob/4.13/parsing/parsetree.mli#L282)\n  ",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "no_toplevel_eval",
    "group": "correctness",
    "level": "deny",
    "impl": "untyped",
    "docs":
      "\n### What it does\nAdding toplevel evaluation statements is not recommended because it forces to add `;;`. Rewrite using `let () = ...`\n  ",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "exc_failwith",
    "group": "suspicious",
    "level": "allow",
    "impl": "typed",
    "docs":
      "\n### What it does\nThe usage of 'Stdlib.failwith' in production code could be error-prone. The constructions `failwith \"not implemented\"` should be implemented sooner or later.\n\nConstructions `failwith \"should not happen\"` smells. Maybe techniques from https://doi.org/10.1145/3299711.3242755 could help.\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "list_length_comparisons",
    "group": "correctness",
    "level": "deny",
    "impl": "typed",
    "docs":
      "\n### What it does\nThe function `Stdlib.List.length` evaluated length of standart OCaml linked lists (`'a list`). There return values supposed to be non-negative, so all code like `List.length .. <= 0` smells bad. If they need to check that list is empty it is more recommended to use pattern matching instead of calculating length, because for large list we will do full iteration, and it will not be too efficient.\n  ",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "propose_function",
    "group": "style",
    "level": "allow",
    "impl": "typed",
    "docs":
      "\n### What it does\nProposes to rewrite 'fun x -> match x with ...' to `function`.\n\n### Why?\nThe `function` keyword allows more shorter syntax for pattern matching on last argument.\nThe lint should not be raised if scrutinee variable is used later in the code.\n\nThe following code is recommended:\n\n```ocaml\n  let f = function\n    | [] -> ...\n    | (x::xs) as arg -> ... x ... xs ... arg\n```\n\nAnd this piece of code is discouraged:\n\n```ocaml\n  let f arg  = match arg with\n    | [] -> ...\n    | (x::xs) -> ... x ... xs ... arg\n```\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "exc_error_swallowing",
    "group": "suspicious",
    "level": "deny",
    "impl": "typed",
    "docs":
      "\n### What it does\nCatching all possible exceptions with wildcard considered as antipattern\n\nSee also https://en.wikipedia.org/wiki/Error_hiding\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "record_1",
    "group": "suspicious",
    "level": "allow",
    "impl": "typed",
    "docs":
      "\n### What it does\nSimplyfies record construction using OCaml-specfic field punning.\n\n(Chapter)[https://dev.realworldocaml.org/records.html] in 'Real World OCaml'.\n\n##### Examples\n\n```ocaml\n{ x = r.x; y = r.y; z = 15}\n```\nvs\n```ocaml\n{ r with z = 15 }\n```\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "wrong_ignoring",
    "group": "suspicious",
    "level": "allow",
    "impl": "typed",
    "docs":
      "\n### What it does\nUsing 'Stdlib.ignore' is discouraged. It's better to rewrite it with let.\n\n#### Explanation\n\nLet's look at expression 'ignore (f x)'. If in the future the function 'f' will accept one more argument or change return type the code above may become buggy, because the function will not be fully applied and executead (although the warning may be raised here if this warning is not masked). It's recommended to rewrite the code as 'let (_ : int) = f x in ...` where 'int' is an example of return type of the function 'f'.\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "list_fusion",
    "group": "perf",
    "level": "warn",
    "impl": "typed",
    "docs": "\n### What it does\n\n#### Explanation\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  },
  {
    "id": "if_bool",
    "group": "style",
    "level": "warn",
    "impl": "typed",
    "docs":
      "\n### What it does+\n\nChecks funny uses of if-then-else expresssion, like 'if true ...', 'if ... then false', etc.\n\n",
    "applicability": {
      "is_multi_part_suggestion": false,
      "applicability": "Unresolved"
    }
  }
]